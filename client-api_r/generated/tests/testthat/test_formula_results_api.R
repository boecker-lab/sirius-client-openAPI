# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate

context("Test FormulaResultsApi")

api_instance <- FormulaResultsApi$new()
compoundId <- "1_Bicuculline_Bicuculline"
formulaId <- "C20H17NO6_[M+H]+"
pid <- "formRes"
dir <- "formResDir"
ProjectSpacesApi$new()$CreateProjectSpace(pid, dir, "/home/runner/work/sirius-client-openAPI/sirius-client-openAPI/.updater/clientTests/Data/test-project-results", TRUE)

test_that("GetBestMatchingCanopusPredictions", {
  # tests for GetBestMatchingCanopusPredictions
  # base path: http://localhost:8080
  # Best matching compound classes,  Set of the highest scoring compound classes CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,
  # Best matching compound classes,  Set of the highest scoring compound classes CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,
  # @param project_id character project-space to read from.
  # @param compound_id character compound/feature the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @return [CompoundClasses]

  resp <- api_instance$GetBestMatchingCanopusPredictions(pid, compoundId, formulaId)
  resp
  
  # response is CompoundClasses instance
  expect_true(inherits(resp, "CompoundClasses"))
})

test_that("GetCanopusPredictions", {
  # tests for GetCanopusPredictions
  # base path: http://localhost:8080
  # All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,
  # All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,
  # @param project_id character project-space to read from.
  # @param compound_id character compound/feature the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @return [CanopusPredictions]

  resp <- api_instance$GetCanopusPredictions(pid, compoundId, formulaId)
  resp
  
  # response is CanopusPredictions instance
  expect_true(inherits(resp, "CanopusPredictions"))
})

test_that("GetFingerprintPrediction", {
  # tests for GetFingerprintPrediction
  # base path: http://localhost:8080
  # Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier  This fingerprint is used to perfom structure database search and predict compound classes.
  # Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier  This fingerprint is used to perfom structure database search and predict compound classes.
  # @param project_id character project-space to read from.
  # @param compound_id character compound/feature the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @return [array[numeric]]

  resp <- api_instance$GetFingerprintPrediction(pid, compoundId, formulaId)
  
  # response is list of doubles
  expect_true(is.list(resp) && all(sapply(resp, is.double)))
})

test_that("GetFormulaIds", {
  # tests for GetFormulaIds
  # base path: http://localhost:8080
  # List of all FormulaResultContainers available for this compound/feature with minimal information.
  # List of all FormulaResultContainers available for this compound/feature with minimal information.  Can be enriched with an optional results overview.
  # @param project_id character project-space to read from.
  # @param compound_id character compound/feature the formula result belongs to.
  # @param result_overview character add ResultOverview to the FormulaResultContainers (optional)
  # @param formula_candidate character add extended formula candidate information to the FormulaResultContainers (optional)
  # @return [array[FormulaResultContainer]]
  
  for (i in c(TRUE, FALSE)) {
    for (j in c(TRUE, FALSE)) {
      resp <- api_instance$GetFormulaIds(pid, compoundId, i, j)
      resp
      # response is array[FormulaResultContainer]
      expect_true(is.list(resp) && all(sapply(resp, function(x) {inherits(x, "FormulaResultContainer")})))
      
      if (i) { expect_true(is.list(resp) && all(sapply(resp, function(x) {inherits(x$resultOverview, "ResultOverview")}))) }
      if (j) { expect_true(is.list(resp) && all(sapply(resp, function(x) {inherits(x$candidate, "FormulaCandidate")}))) }
    }
  }
})

test_that("GetFormulaResult", {
  # tests for GetFormulaResult
  # base path: http://localhost:8080
  # FormulaResultContainers for the given &#39;formulaId&#39; with minimal information.
  # FormulaResultContainers for the given &#39;formulaId&#39; with minimal information.  Can be enriched with an optional results overview and formula candidate information.
  # @param project_id character project-space to read from.
  # @param compound_id character compound/feature the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @param result_overview character add ResultOverview to the FormulaResultContainer (optional)
  # @param formula_candidate character add extended formula candidate information to the FormulaResultContainer (optional)
  # @return [FormulaResultContainer]

  for (i in c(TRUE, FALSE)) {
    for (j in c(TRUE, FALSE)) {
      resp <- api_instance$GetFormulaResult(pid, compoundId, formulaId, i, j)
      resp
      # response is FormulaResultContainer instance
      expect_true(inherits(resp, "FormulaResultContainer"))
      
      if (i) { expect_true(inherits(resp$resultOverview, "ResultOverview")) }
      if (j) { expect_true(inherits(resp$candidate, "FormulaCandidate")) }
    }
  }
})

test_that("GetFragTree", {
  # tests for GetFragTree
  # base path: http://localhost:8080
  # Returns fragmentation tree (SIRIUS) for the given formula result identifier  This tree is used to rank formula candidates (treeScore).
  # Returns fragmentation tree (SIRIUS) for the given formula result identifier  This tree is used to rank formula candidates (treeScore).
  # @param project_id character project-space to read from.
  # @param compound_id character compound/feature the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @return [FragmentationTree]

  resp <- api_instance$GetFragTree(pid, compoundId, formulaId)
  resp
  
  # response is FragmentationTree instance
  expect_true(inherits(resp, "FragmentationTree"))
})

test_that("GetSimulatedIsotopePattern", {
  # tests for GetSimulatedIsotopePattern
  # base path: http://localhost:8080
  # Returns simulated isotope pattern (SIRIUS) for the given formula result identifier.
  # Returns simulated isotope pattern (SIRIUS) for the given formula result identifier.  This simulated isotope pattern is used to rank formula candidates (treeScore).
  # @param project_id character project-space to read from.
  # @param compound_id character compound/feature the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @return [AnnotatedSpectrum]

  resp <- api_instance$GetSimulatedIsotopePattern(pid, compoundId, formulaId)
  resp
  
  # response is AnnotatedSpectrum instance
  expect_true(inherits(resp, "AnnotatedSpectrum"))
})

test_that("GetStructureCandidates", {
  # tests for GetStructureCandidates
  # base path: http://localhost:8080
  # List of StructureCandidates the given &#39;formulaId&#39; with minimal information.
  # List of StructureCandidates the given &#39;formulaId&#39; with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links and pubmed ids,
  # @param project_id character project-space to read from.
  # @param compound_id character compound/feature the formula result belongs to.
  # @param formula_id character identifier of the requested formula result
  # @param fingerprint character add molecular fingerprint to StructureCandidates (optional)
  # @param db_links character add dbLinks to StructureCandidates (optional)
  # @param pub_med_ids character add PubMedIds (citation count) to StructureCandidates (optional)
  # @param top_k integer retrieve only the top k StructureCandidates (optional)
  # @return [array[StructureCandidate]]

  count = 0
  num = c(-1,70,60,50,40,30,20,10)
  for (i in c(TRUE, FALSE)) {
    for (j in c(TRUE, FALSE)) {
      for (k in c(TRUE, FALSE)) {
        count = count + 1
        resp <- api_instance$GetStructureCandidates(pid, compoundId, formulaId, i, j, k, num[count])
        resp
        # response is array[StructureCandidate]
        expect_true(is.list(resp) && all(sapply(resp, function(x) {inherits(x, "StructureCandidate")})))
      }
    }
  }
})

test_that("GetTopStructureCandidate", {
  # tests for GetTopStructureCandidate
  # base path: http://localhost:8080
  # Best Scoring StructureCandidate over all molecular formular resutls that belong to the specified  compound/feature (compoundId).
  # Best Scoring StructureCandidate over all molecular formular resutls that belong to the specified  compound/feature (compoundId).
  # @param project_id character project-space to read from.
  # @param compound_id character compound/feature the formula result belongs to.
  # @param fingerprint character add molecular fingerprint to StructureCandidates (optional)
  # @param db_links character add dbLinks to StructureCandidates (optional)
  # @param pub_med_ids character add PubMedIds (citation count) to StructureCandidates (optional)
  # @return [StructureCandidate]

  for (i in c(TRUE, FALSE)) {
    for (j in c(TRUE, FALSE)) {
      for (k in c(TRUE, FALSE)) {
        resp <- api_instance$GetTopStructureCandidate(pid, compoundId, i, j, k)
        resp
        # response is StructureCandidate instance
        expect_true(inherits(resp, "StructureCandidate"))

        # fpBitsSet is list of length > 0 and filled with Integers
        if (i) { expect_true(is.list(resp$fpBitsSet) && 
                             length(resp$fpBitsSet) > 0 && 
                             all(sapply(resp$fpBitsSet, function(x) {x%%1==0}))) }
        # dbLinks is list of length > 0 and filled with DBLink instances
        if (j) { expect_true(is.list(resp$dbLinks) && 
                             length(resp$dbLinks) > 0 && 
                             all(sapply(resp$dbLinks, function(x) {inherits(x, "DBLink")}))) }
        # pubmedIds is list of length > 0 and filled with Integers
        if (k) { expect_true(is.list(resp$pubmedIds) &&
                             length(resp$pubmedIds) > 0  && 
                             all(sapply(resp$pubmedIds, function(x) {x%%1==0}))) }
      }
    }
  }
})

withr::defer(formula_results_td(c(pid, dir)))
