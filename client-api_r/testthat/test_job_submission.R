# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate

context("Test JobSubmission")

model_instance <- JobSubmission$new()

test_that("compoundIds", {
  # tests for the property `compoundIds` (array[character])
  # Compounds that should be the input for this Job

  # uncomment below to test the property
  #expect_equal(model.instance$`compoundIds`, "EXPECTED_RESULT")
})

test_that("fallbackAdducts", {
  # tests for the property `fallbackAdducts` (array[character])
  # Describes how to deal with Adducts: Fallback adducts are considered if the auto detection did not find any indication for an ion mode.  Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+  Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-

  # uncomment below to test the property
  #expect_equal(model.instance$`fallbackAdducts`, "EXPECTED_RESULT")
})

test_that("enforcedAdducts", {
  # tests for the property `enforcedAdducts` (array[character])
  # Describes how to deal with Adducts:  Enforced adducts that are always considered.  Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+  Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-

  # uncomment below to test the property
  #expect_equal(model.instance$`enforcedAdducts`, "EXPECTED_RESULT")
})

test_that("detectableAdducts", {
  # tests for the property `detectableAdducts` (array[character])
  # Describes how to deal with Adducts: Detectable adducts which are only considered if there is an indication in the MS1 scan (e.g. correct mass delta).  Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+  Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-

  # uncomment below to test the property
  #expect_equal(model.instance$`detectableAdducts`, "EXPECTED_RESULT")
})

test_that("recompute", {
  # tests for the property `recompute` (character)
  # Indicate if already existing result for a tool to be executed should be overwritten or not.

  # uncomment below to test the property
  #expect_equal(model.instance$`recompute`, "EXPECTED_RESULT")
})

test_that("formulaIdParas", {
  # tests for the property `formulaIdParas` (Sirius)

  # uncomment below to test the property
  #expect_equal(model.instance$`formulaIdParas`, "EXPECTED_RESULT")
})

test_that("zodiacParas", {
  # tests for the property `zodiacParas` (Zodiac)

  # uncomment below to test the property
  #expect_equal(model.instance$`zodiacParas`, "EXPECTED_RESULT")
})

test_that("fingerprintPredictionParas", {
  # tests for the property `fingerprintPredictionParas` (FingerprintPrediction)

  # uncomment below to test the property
  #expect_equal(model.instance$`fingerprintPredictionParas`, "EXPECTED_RESULT")
})

test_that("structureDbSearchParas", {
  # tests for the property `structureDbSearchParas` (StructureDbSearch)

  # uncomment below to test the property
  #expect_equal(model.instance$`structureDbSearchParas`, "EXPECTED_RESULT")
})

test_that("canopusParas", {
  # tests for the property `canopusParas` (Canopus)

  # uncomment below to test the property
  #expect_equal(model.instance$`canopusParas`, "EXPECTED_RESULT")
})

test_that("configMap", {
  # tests for the property `configMap` (map(character))
  # As an alternative to the object based parameters, this map allows to store key value pairs  of ALL SIRIUS parameters. All possible parameters can be retrieved from SIRIUS via the respective endpoint.

  # uncomment below to test the property
  #expect_equal(model.instance$`configMap`, "EXPECTED_RESULT")
})
