# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate

context("Test Sirius")

model_instance <- Sirius$new()

test_that("enabled", {
  # tests for the property `enabled` (character)
  # tags whether the tool is enabled

  # uncomment below to test the property
  #expect_equal(model.instance$`enabled`, "EXPECTED_RESULT")
})

test_that("profile", {
  # tests for the property `profile` (character)
  # Instrument specific profile for internal algorithms  Just select what comes closest to the instrument that was used for measuring the data.

  # uncomment below to test the property
  #expect_equal(model.instance$`profile`, "EXPECTED_RESULT")
})

test_that("numberOfCandidates", {
  # tests for the property `numberOfCandidates` (integer)
  # Number of formula candidates to keep as result list (Formula Candidates).

  # uncomment below to test the property
  #expect_equal(model.instance$`numberOfCandidates`, "EXPECTED_RESULT")
})

test_that("numberOfCandidatesPerIon", {
  # tests for the property `numberOfCandidatesPerIon` (integer)
  # Use this parameter if you want to force SIRIUS to report at least  NumberOfCandidatesPerIon results per ionization.  if &lt;&#x3D; 0, this parameter will have no effect and just the top  NumberOfCandidates results will be reported.

  # uncomment below to test the property
  #expect_equal(model.instance$`numberOfCandidatesPerIon`, "EXPECTED_RESULT")
})

test_that("massAccuracyMS2ppm", {
  # tests for the property `massAccuracyMS2ppm` (numeric)
  # Maximum allowed mass accuracy. Only molecular formulas within this mass window are considered.

  # uncomment below to test the property
  #expect_equal(model.instance$`massAccuracyMS2ppm`, "EXPECTED_RESULT")
})

test_that("isotopeMs2Settings", {
  # tests for the property `isotopeMs2Settings` (character)
  # Specify how isotope patterns in MS/MS should be handled.  &lt;p&gt;  FILTER: When filtering is enabled, molecular formulas are excluded if their  theoretical isotope pattern does not match the theoretical one, even if their MS/MS pattern has high score.  &lt;p&gt;  SCORE: Use them for SCORING. To use this the instrument should produce clear MS/MS isotope patterns  &lt;p&gt;  IGNORE: Ignore that there might be isotope patterns in MS/MS

  # uncomment below to test the property
  #expect_equal(model.instance$`isotopeMs2Settings`, "EXPECTED_RESULT")
})

test_that("formulaSearchDBs", {
  # tests for the property `formulaSearchDBs` (array[character])
  # List Structure database to extract molecular formulas from to reduce formula search space.  SIRIUS is quite good at de novo formula annotation, so only enable if you have a good reason.

  # uncomment below to test the property
  #expect_equal(model.instance$`formulaSearchDBs`, "EXPECTED_RESULT")
})

test_that("enforcedFormulaConstraints", {
  # tests for the property `enforcedFormulaConstraints` (character)
  # These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  &lt;p&gt;  Enforced: Enforced elements are always considered

  # uncomment below to test the property
  #expect_equal(model.instance$`enforcedFormulaConstraints`, "EXPECTED_RESULT")
})

test_that("fallbackFormulaConstraints", {
  # tests for the property `fallbackFormulaConstraints` (character)
  # These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  &lt;p&gt;  Fallback: Fallback elements are used, if the auto-detection fails (e.g. no isotope pattern available)

  # uncomment below to test the property
  #expect_equal(model.instance$`fallbackFormulaConstraints`, "EXPECTED_RESULT")
})

test_that("detectableElements", {
  # tests for the property `detectableElements` (array[character])
  # These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  &lt;p&gt;  Detectable: Detectable elements are added to the chemical alphabet, if there are indications for them (e.g. in isotope pattern)

  # uncomment below to test the property
  #expect_equal(model.instance$`detectableElements`, "EXPECTED_RESULT")
})

test_that("ilpTimeout", {
  # tests for the property `ilpTimeout` (Timeout)

  # uncomment below to test the property
  #expect_equal(model.instance$`ilpTimeout`, "EXPECTED_RESULT")
})

test_that("useHeuristic", {
  # tests for the property `useHeuristic` (UseHeuristic)

  # uncomment below to test the property
  #expect_equal(model.instance$`useHeuristic`, "EXPECTED_RESULT")
})
