# coding: utf-8

"""
    SIRIUS Nightsky API

    OpenAPI REST API that provides the full functionality of SIRIUS and its web services as background service. It is intended as entry-point for scripting languages and software integration SDKs.The provided OpenAPI specification allows to autogenerate clients for different programming languages.

    The version of the OpenAPI document: 0.9
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from PySirius.models.timeout import Timeout
from PySirius.models.use_heuristic import UseHeuristic
from typing import Optional, Set
from typing_extensions import Self

class Sirius(BaseModel):
    """
    User/developer friendly parameter subset for the Formula/SIRIUS tool
    """ # noqa: E501
    enabled: Optional[StrictBool] = Field(default=None, description="tags whether the tool is enabled")
    profile: Optional[StrictStr] = Field(default=None, description="Instrument specific profile for internal algorithms  Just select what comes closest to the instrument that was used for measuring the data.")
    number_of_candidates: Optional[StrictInt] = Field(default=None, description="Number of formula candidates to keep as result list (Formula Candidates).", alias="numberOfCandidates")
    number_of_candidates_per_ion: Optional[StrictInt] = Field(default=None, description="Use this parameter if you want to force SIRIUS to report at least  NumberOfCandidatesPerIon results per ionization.  if <= 0, this parameter will have no effect and just the top  NumberOfCandidates results will be reported.", alias="numberOfCandidatesPerIon")
    mass_accuracy_ms2ppm: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Maximum allowed mass accuracy. Only molecular formulas within this mass window are considered.", alias="massAccuracyMS2ppm")
    isotope_ms2_settings: Optional[StrictStr] = Field(default=None, description="Specify how isotope patterns in MS/MS should be handled.  <p>  FILTER: When filtering is enabled, molecular formulas are excluded if their  theoretical isotope pattern does not match the theoretical one, even if their MS/MS pattern has high score.  <p>  SCORE: Use them for SCORING. To use this the instrument should produce clear MS/MS isotope patterns  <p>  IGNORE: Ignore that there might be isotope patterns in MS/MS", alias="isotopeMs2Settings")
    formula_search_dbs: Optional[List[StrictStr]] = Field(default=None, description="List Structure database to extract molecular formulas from to reduce formula search space.  SIRIUS is quite good at de novo formula annotation, so only enable if you have a good reason.", alias="formulaSearchDBs")
    enforced_formula_constraints: Optional[StrictStr] = Field(default=None, description="These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  <p>  Enforced: Enforced elements are always considered", alias="enforcedFormulaConstraints")
    fallback_formula_constraints: Optional[StrictStr] = Field(default=None, description="These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  <p>  Fallback: Fallback elements are used, if the auto-detection fails (e.g. no isotope pattern available)", alias="fallbackFormulaConstraints")
    detectable_elements: Optional[List[StrictStr]] = Field(default=None, description="These configurations hold the information how to autodetect elements based on the given formula constraints.  Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.  <p>  Detectable: Detectable elements are added to the chemical alphabet, if there are indications for them (e.g. in isotope pattern)", alias="detectableElements")
    ilp_timeout: Optional[Timeout] = Field(default=None, alias="ilpTimeout")
    use_heuristic: Optional[UseHeuristic] = Field(default=None, alias="useHeuristic")
    __properties: ClassVar[List[str]] = ["enabled", "profile", "numberOfCandidates", "numberOfCandidatesPerIon", "massAccuracyMS2ppm", "isotopeMs2Settings", "formulaSearchDBs", "enforcedFormulaConstraints", "fallbackFormulaConstraints", "detectableElements", "ilpTimeout", "useHeuristic"]

    @field_validator('profile')
    def profile_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['QTOF', 'ORBI', 'FTICR']):
            raise ValueError("must be one of enum values ('QTOF', 'ORBI', 'FTICR')")
        return value

    @field_validator('isotope_ms2_settings')
    def isotope_ms2_settings_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['IGNORE', 'FILTER', 'SCORE']):
            raise ValueError("must be one of enum values ('IGNORE', 'FILTER', 'SCORE')")
        return value

    @field_validator('formula_search_dbs')
    def formula_search_dbs_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['ALL', 'ALL_BUT_INSILICO', 'PUBCHEM', 'MESH', 'HMDB', 'KNAPSACK', 'CHEBI', 'PUBMED', 'BIO', 'KEGG', 'HSDB', 'MACONDA', 'METACYC', 'GNPS', 'ZINCBIO', 'TRAIN', 'UNDP', 'YMDB', 'PLANTCYC', 'NORMAN', 'ADDITIONAL', 'SUPERNATURAL', 'COCONUT', 'PUBCHEMANNOTATIONBIO', 'PUBCHEMANNOTATIONDRUG', 'PUBCHEMANNOTATIONSAFETYANDTOXIC', 'PUBCHEMANNOTATIONFOOD', 'LIPID', 'KEGGMINE', 'ECOCYCMINE', 'YMDBMINE']):
                raise ValueError("each list item must be one of ('ALL', 'ALL_BUT_INSILICO', 'PUBCHEM', 'MESH', 'HMDB', 'KNAPSACK', 'CHEBI', 'PUBMED', 'BIO', 'KEGG', 'HSDB', 'MACONDA', 'METACYC', 'GNPS', 'ZINCBIO', 'TRAIN', 'UNDP', 'YMDB', 'PLANTCYC', 'NORMAN', 'ADDITIONAL', 'SUPERNATURAL', 'COCONUT', 'PUBCHEMANNOTATIONBIO', 'PUBCHEMANNOTATIONDRUG', 'PUBCHEMANNOTATIONSAFETYANDTOXIC', 'PUBCHEMANNOTATIONFOOD', 'LIPID', 'KEGGMINE', 'ECOCYCMINE', 'YMDBMINE')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Sirius from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of ilp_timeout
        if self.ilp_timeout:
            _dict['ilpTimeout'] = self.ilp_timeout.to_dict()
        # override the default output from pydantic by calling `to_dict()` of use_heuristic
        if self.use_heuristic:
            _dict['useHeuristic'] = self.use_heuristic.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Sirius from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "enabled": obj.get("enabled"),
            "profile": obj.get("profile"),
            "numberOfCandidates": obj.get("numberOfCandidates"),
            "numberOfCandidatesPerIon": obj.get("numberOfCandidatesPerIon"),
            "massAccuracyMS2ppm": obj.get("massAccuracyMS2ppm"),
            "isotopeMs2Settings": obj.get("isotopeMs2Settings"),
            "formulaSearchDBs": obj.get("formulaSearchDBs"),
            "enforcedFormulaConstraints": obj.get("enforcedFormulaConstraints"),
            "fallbackFormulaConstraints": obj.get("fallbackFormulaConstraints"),
            "detectableElements": obj.get("detectableElements"),
            "ilpTimeout": Timeout.from_dict(obj["ilpTimeout"]) if obj.get("ilpTimeout") is not None else None,
            "useHeuristic": UseHeuristic.from_dict(obj["useHeuristic"]) if obj.get("useHeuristic") is not None else None
        })
        return _obj


