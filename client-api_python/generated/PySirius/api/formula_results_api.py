# coding: utf-8

"""
    SIRIUS Nightsky API

    OpenAPI REST API that provides the full functionality of SIRIUS and its web services as background service. It is intended as entry-point for scripting languages and software integration SDKs.The provided OpenAPI specification allows to autogenerate clients for different programming languages.

    The version of the OpenAPI document: 0.9
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import Optional
from typing_extensions import Annotated
from PySirius.models.annotated_spectrum import AnnotatedSpectrum
from PySirius.models.canopus_predictions import CanopusPredictions
from PySirius.models.compound_classes import CompoundClasses
from PySirius.models.formula_result_container import FormulaResultContainer
from PySirius.models.fragmentation_tree import FragmentationTree
from PySirius.models.structure_candidate import StructureCandidate

from PySirius.api_client import ApiClient, RequestSerialized
from PySirius.api_response import ApiResponse
from PySirius.rest import RESTResponseType


class FormulaResultsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_best_matching_canopus_predictions(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CompoundClasses:
        """Best matching compound classes,  Set of the highest scoring compound classes CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,

        Best matching compound classes,  Set of the highest scoring compound classes CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_best_matching_canopus_predictions_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompoundClasses",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_best_matching_canopus_predictions_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CompoundClasses]:
        """Best matching compound classes,  Set of the highest scoring compound classes CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,

        Best matching compound classes,  Set of the highest scoring compound classes CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_best_matching_canopus_predictions_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompoundClasses",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_best_matching_canopus_predictions_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Best matching compound classes,  Set of the highest scoring compound classes CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,

        Best matching compound classes,  Set of the highest scoring compound classes CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_best_matching_canopus_predictions_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompoundClasses",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_best_matching_canopus_predictions_serialize(
        self,
        project_id,
        compound_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if compound_id is not None:
            _path_params['compoundId'] = compound_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}/best-canopus-predictions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_canopus_predictions(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CanopusPredictions:
        """All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_canopus_predictions_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CanopusPredictions",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_canopus_predictions_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CanopusPredictions]:
        """All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_canopus_predictions_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CanopusPredictions",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_canopus_predictions_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_canopus_predictions_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CanopusPredictions",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_canopus_predictions_serialize(
        self,
        project_id,
        compound_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if compound_id is not None:
            _path_params['compoundId'] = compound_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}/canopus-predictions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fingerprint_prediction(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[float]:
        """Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier  This fingerprint is used to perfom structure database search and predict compound classes.

        Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier  This fingerprint is used to perfom structure database search and predict compound classes.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_prediction_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fingerprint_prediction_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[float]]:
        """Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier  This fingerprint is used to perfom structure database search and predict compound classes.

        Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier  This fingerprint is used to perfom structure database search and predict compound classes.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_prediction_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fingerprint_prediction_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier  This fingerprint is used to perfom structure database search and predict compound classes.

        Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier  This fingerprint is used to perfom structure database search and predict compound classes.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_prediction_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fingerprint_prediction_serialize(
        self,
        project_id,
        compound_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if compound_id is not None:
            _path_params['compoundId'] = compound_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}/fingerprint',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_formula_ids(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        result_overview: Annotated[Optional[StrictBool], Field(description="add ResultOverview to the FormulaResultContainers")] = None,
        formula_candidate: Annotated[Optional[StrictBool], Field(description="add extended formula candidate information to the FormulaResultContainers")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[FormulaResultContainer]:
        """List of all FormulaResultContainers available for this compound/feature with minimal information.

        List of all FormulaResultContainers available for this compound/feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param result_overview: add ResultOverview to the FormulaResultContainers
        :type result_overview: bool
        :param formula_candidate: add extended formula candidate information to the FormulaResultContainers
        :type formula_candidate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_ids_serialize(
            project_id=project_id,
            compound_id=compound_id,
            result_overview=result_overview,
            formula_candidate=formula_candidate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FormulaResultContainer]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_formula_ids_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        result_overview: Annotated[Optional[StrictBool], Field(description="add ResultOverview to the FormulaResultContainers")] = None,
        formula_candidate: Annotated[Optional[StrictBool], Field(description="add extended formula candidate information to the FormulaResultContainers")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[FormulaResultContainer]]:
        """List of all FormulaResultContainers available for this compound/feature with minimal information.

        List of all FormulaResultContainers available for this compound/feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param result_overview: add ResultOverview to the FormulaResultContainers
        :type result_overview: bool
        :param formula_candidate: add extended formula candidate information to the FormulaResultContainers
        :type formula_candidate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_ids_serialize(
            project_id=project_id,
            compound_id=compound_id,
            result_overview=result_overview,
            formula_candidate=formula_candidate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FormulaResultContainer]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_formula_ids_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        result_overview: Annotated[Optional[StrictBool], Field(description="add ResultOverview to the FormulaResultContainers")] = None,
        formula_candidate: Annotated[Optional[StrictBool], Field(description="add extended formula candidate information to the FormulaResultContainers")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of all FormulaResultContainers available for this compound/feature with minimal information.

        List of all FormulaResultContainers available for this compound/feature with minimal information.  Can be enriched with an optional results overview.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param result_overview: add ResultOverview to the FormulaResultContainers
        :type result_overview: bool
        :param formula_candidate: add extended formula candidate information to the FormulaResultContainers
        :type formula_candidate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_ids_serialize(
            project_id=project_id,
            compound_id=compound_id,
            result_overview=result_overview,
            formula_candidate=formula_candidate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FormulaResultContainer]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_formula_ids_serialize(
        self,
        project_id,
        compound_id,
        result_overview,
        formula_candidate,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if compound_id is not None:
            _path_params['compoundId'] = compound_id
        # process the query parameters
        if result_overview is not None:
            
            _query_params.append(('resultOverview', result_overview))
            
        if formula_candidate is not None:
            
            _query_params.append(('formulaCandidate', formula_candidate))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/compounds/{compoundId}/formulas',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_formula_result(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        result_overview: Annotated[Optional[StrictBool], Field(description="add ResultOverview to the FormulaResultContainer")] = None,
        formula_candidate: Annotated[Optional[StrictBool], Field(description="add extended formula candidate information to the FormulaResultContainer")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FormulaResultContainer:
        """FormulaResultContainers for the given 'formulaId' with minimal information.

        FormulaResultContainers for the given 'formulaId' with minimal information.  Can be enriched with an optional results overview and formula candidate information.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param result_overview: add ResultOverview to the FormulaResultContainer
        :type result_overview: bool
        :param formula_candidate: add extended formula candidate information to the FormulaResultContainer
        :type formula_candidate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_result_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            result_overview=result_overview,
            formula_candidate=formula_candidate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FormulaResultContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_formula_result_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        result_overview: Annotated[Optional[StrictBool], Field(description="add ResultOverview to the FormulaResultContainer")] = None,
        formula_candidate: Annotated[Optional[StrictBool], Field(description="add extended formula candidate information to the FormulaResultContainer")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FormulaResultContainer]:
        """FormulaResultContainers for the given 'formulaId' with minimal information.

        FormulaResultContainers for the given 'formulaId' with minimal information.  Can be enriched with an optional results overview and formula candidate information.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param result_overview: add ResultOverview to the FormulaResultContainer
        :type result_overview: bool
        :param formula_candidate: add extended formula candidate information to the FormulaResultContainer
        :type formula_candidate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_result_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            result_overview=result_overview,
            formula_candidate=formula_candidate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FormulaResultContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_formula_result_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        result_overview: Annotated[Optional[StrictBool], Field(description="add ResultOverview to the FormulaResultContainer")] = None,
        formula_candidate: Annotated[Optional[StrictBool], Field(description="add extended formula candidate information to the FormulaResultContainer")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """FormulaResultContainers for the given 'formulaId' with minimal information.

        FormulaResultContainers for the given 'formulaId' with minimal information.  Can be enriched with an optional results overview and formula candidate information.

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param result_overview: add ResultOverview to the FormulaResultContainer
        :type result_overview: bool
        :param formula_candidate: add extended formula candidate information to the FormulaResultContainer
        :type formula_candidate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_formula_result_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            result_overview=result_overview,
            formula_candidate=formula_candidate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FormulaResultContainer",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_formula_result_serialize(
        self,
        project_id,
        compound_id,
        formula_id,
        result_overview,
        formula_candidate,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if compound_id is not None:
            _path_params['compoundId'] = compound_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if result_overview is not None:
            
            _query_params.append(('resultOverview', result_overview))
            
        if formula_candidate is not None:
            
            _query_params.append(('formulaCandidate', formula_candidate))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_frag_tree(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FragmentationTree:
        """Returns fragmentation tree (SIRIUS) for the given formula result identifier  This tree is used to rank formula candidates (treeScore).

        Returns fragmentation tree (SIRIUS) for the given formula result identifier  This tree is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_frag_tree_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FragmentationTree",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_frag_tree_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FragmentationTree]:
        """Returns fragmentation tree (SIRIUS) for the given formula result identifier  This tree is used to rank formula candidates (treeScore).

        Returns fragmentation tree (SIRIUS) for the given formula result identifier  This tree is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_frag_tree_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FragmentationTree",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_frag_tree_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns fragmentation tree (SIRIUS) for the given formula result identifier  This tree is used to rank formula candidates (treeScore).

        Returns fragmentation tree (SIRIUS) for the given formula result identifier  This tree is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_frag_tree_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FragmentationTree",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_frag_tree_serialize(
        self,
        project_id,
        compound_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if compound_id is not None:
            _path_params['compoundId'] = compound_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}/tree',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_simulated_isotope_pattern(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AnnotatedSpectrum:
        """Returns simulated isotope pattern (SIRIUS) for the given formula result identifier.

        Returns simulated isotope pattern (SIRIUS) for the given formula result identifier.  This simulated isotope pattern is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_simulated_isotope_pattern_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_simulated_isotope_pattern_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AnnotatedSpectrum]:
        """Returns simulated isotope pattern (SIRIUS) for the given formula result identifier.

        Returns simulated isotope pattern (SIRIUS) for the given formula result identifier.  This simulated isotope pattern is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_simulated_isotope_pattern_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_simulated_isotope_pattern_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns simulated isotope pattern (SIRIUS) for the given formula result identifier.

        Returns simulated isotope pattern (SIRIUS) for the given formula result identifier.  This simulated isotope pattern is used to rank formula candidates (treeScore).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_simulated_isotope_pattern_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AnnotatedSpectrum",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_simulated_isotope_pattern_serialize(
        self,
        project_id,
        compound_id,
        formula_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if compound_id is not None:
            _path_params['compoundId'] = compound_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}/isotope-pattern',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_structure_candidates(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        fingerprint: Annotated[Optional[StrictBool], Field(description="add molecular fingerprint to StructureCandidates")] = None,
        db_links: Annotated[Optional[StrictBool], Field(description="add dbLinks to StructureCandidates")] = None,
        pub_med_ids: Annotated[Optional[StrictBool], Field(description="add PubMedIds (citation count) to StructureCandidates")] = None,
        top_k: Annotated[Optional[StrictInt], Field(description="retrieve only the top k StructureCandidates")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[StructureCandidate]:
        """List of StructureCandidates the given 'formulaId' with minimal information.

        List of StructureCandidates the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links and pubmed ids,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param fingerprint: add molecular fingerprint to StructureCandidates
        :type fingerprint: bool
        :param db_links: add dbLinks to StructureCandidates
        :type db_links: bool
        :param pub_med_ids: add PubMedIds (citation count) to StructureCandidates
        :type pub_med_ids: bool
        :param top_k: retrieve only the top k StructureCandidates
        :type top_k: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            fingerprint=fingerprint,
            db_links=db_links,
            pub_med_ids=pub_med_ids,
            top_k=top_k,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidate]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_structure_candidates_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        fingerprint: Annotated[Optional[StrictBool], Field(description="add molecular fingerprint to StructureCandidates")] = None,
        db_links: Annotated[Optional[StrictBool], Field(description="add dbLinks to StructureCandidates")] = None,
        pub_med_ids: Annotated[Optional[StrictBool], Field(description="add PubMedIds (citation count) to StructureCandidates")] = None,
        top_k: Annotated[Optional[StrictInt], Field(description="retrieve only the top k StructureCandidates")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[StructureCandidate]]:
        """List of StructureCandidates the given 'formulaId' with minimal information.

        List of StructureCandidates the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links and pubmed ids,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param fingerprint: add molecular fingerprint to StructureCandidates
        :type fingerprint: bool
        :param db_links: add dbLinks to StructureCandidates
        :type db_links: bool
        :param pub_med_ids: add PubMedIds (citation count) to StructureCandidates
        :type pub_med_ids: bool
        :param top_k: retrieve only the top k StructureCandidates
        :type top_k: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            fingerprint=fingerprint,
            db_links=db_links,
            pub_med_ids=pub_med_ids,
            top_k=top_k,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidate]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_structure_candidates_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        formula_id: Annotated[StrictStr, Field(description="identifier of the requested formula result")],
        fingerprint: Annotated[Optional[StrictBool], Field(description="add molecular fingerprint to StructureCandidates")] = None,
        db_links: Annotated[Optional[StrictBool], Field(description="add dbLinks to StructureCandidates")] = None,
        pub_med_ids: Annotated[Optional[StrictBool], Field(description="add PubMedIds (citation count) to StructureCandidates")] = None,
        top_k: Annotated[Optional[StrictInt], Field(description="retrieve only the top k StructureCandidates")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of StructureCandidates the given 'formulaId' with minimal information.

        List of StructureCandidates the given 'formulaId' with minimal information.  StructureCandidates can be enriched with molecular fingerprint, structure database links and pubmed ids,

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param formula_id: identifier of the requested formula result (required)
        :type formula_id: str
        :param fingerprint: add molecular fingerprint to StructureCandidates
        :type fingerprint: bool
        :param db_links: add dbLinks to StructureCandidates
        :type db_links: bool
        :param pub_med_ids: add PubMedIds (citation count) to StructureCandidates
        :type pub_med_ids: bool
        :param top_k: retrieve only the top k StructureCandidates
        :type top_k: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_structure_candidates_serialize(
            project_id=project_id,
            compound_id=compound_id,
            formula_id=formula_id,
            fingerprint=fingerprint,
            db_links=db_links,
            pub_med_ids=pub_med_ids,
            top_k=top_k,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StructureCandidate]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_structure_candidates_serialize(
        self,
        project_id,
        compound_id,
        formula_id,
        fingerprint,
        db_links,
        pub_med_ids,
        top_k,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if compound_id is not None:
            _path_params['compoundId'] = compound_id
        if formula_id is not None:
            _path_params['formulaId'] = formula_id
        # process the query parameters
        if fingerprint is not None:
            
            _query_params.append(('fingerprint', fingerprint))
            
        if db_links is not None:
            
            _query_params.append(('dbLinks', db_links))
            
        if pub_med_ids is not None:
            
            _query_params.append(('pubMedIds', pub_med_ids))
            
        if top_k is not None:
            
            _query_params.append(('topK', top_k))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/compounds/{compoundId}/formulas/{formulaId}/structures',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_top_structure_candidate(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        fingerprint: Annotated[Optional[StrictBool], Field(description="add molecular fingerprint to StructureCandidates")] = None,
        db_links: Annotated[Optional[StrictBool], Field(description="add dbLinks to StructureCandidates")] = None,
        pub_med_ids: Annotated[Optional[StrictBool], Field(description="add PubMedIds (citation count) to StructureCandidates")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> StructureCandidate:
        """Best Scoring StructureCandidate over all molecular formular resutls that belong to the specified  compound/feature (compoundId).

        Best Scoring StructureCandidate over all molecular formular resutls that belong to the specified  compound/feature (compoundId).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param fingerprint: add molecular fingerprint to StructureCandidates
        :type fingerprint: bool
        :param db_links: add dbLinks to StructureCandidates
        :type db_links: bool
        :param pub_med_ids: add PubMedIds (citation count) to StructureCandidates
        :type pub_med_ids: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_top_structure_candidate_serialize(
            project_id=project_id,
            compound_id=compound_id,
            fingerprint=fingerprint,
            db_links=db_links,
            pub_med_ids=pub_med_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StructureCandidate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_top_structure_candidate_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        fingerprint: Annotated[Optional[StrictBool], Field(description="add molecular fingerprint to StructureCandidates")] = None,
        db_links: Annotated[Optional[StrictBool], Field(description="add dbLinks to StructureCandidates")] = None,
        pub_med_ids: Annotated[Optional[StrictBool], Field(description="add PubMedIds (citation count) to StructureCandidates")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[StructureCandidate]:
        """Best Scoring StructureCandidate over all molecular formular resutls that belong to the specified  compound/feature (compoundId).

        Best Scoring StructureCandidate over all molecular formular resutls that belong to the specified  compound/feature (compoundId).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param fingerprint: add molecular fingerprint to StructureCandidates
        :type fingerprint: bool
        :param db_links: add dbLinks to StructureCandidates
        :type db_links: bool
        :param pub_med_ids: add PubMedIds (citation count) to StructureCandidates
        :type pub_med_ids: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_top_structure_candidate_serialize(
            project_id=project_id,
            compound_id=compound_id,
            fingerprint=fingerprint,
            db_links=db_links,
            pub_med_ids=pub_med_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StructureCandidate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_top_structure_candidate_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project-space to read from.")],
        compound_id: Annotated[StrictStr, Field(description="compound/feature the formula result belongs to.")],
        fingerprint: Annotated[Optional[StrictBool], Field(description="add molecular fingerprint to StructureCandidates")] = None,
        db_links: Annotated[Optional[StrictBool], Field(description="add dbLinks to StructureCandidates")] = None,
        pub_med_ids: Annotated[Optional[StrictBool], Field(description="add PubMedIds (citation count) to StructureCandidates")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Best Scoring StructureCandidate over all molecular formular resutls that belong to the specified  compound/feature (compoundId).

        Best Scoring StructureCandidate over all molecular formular resutls that belong to the specified  compound/feature (compoundId).

        :param project_id: project-space to read from. (required)
        :type project_id: str
        :param compound_id: compound/feature the formula result belongs to. (required)
        :type compound_id: str
        :param fingerprint: add molecular fingerprint to StructureCandidates
        :type fingerprint: bool
        :param db_links: add dbLinks to StructureCandidates
        :type db_links: bool
        :param pub_med_ids: add PubMedIds (citation count) to StructureCandidates
        :type pub_med_ids: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_top_structure_candidate_serialize(
            project_id=project_id,
            compound_id=compound_id,
            fingerprint=fingerprint,
            db_links=db_links,
            pub_med_ids=pub_med_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StructureCandidate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_top_structure_candidate_serialize(
        self,
        project_id,
        compound_id,
        fingerprint,
        db_links,
        pub_med_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params['projectId'] = project_id
        if compound_id is not None:
            _path_params['compoundId'] = compound_id
        # process the query parameters
        if fingerprint is not None:
            
            _query_params.append(('fingerprint', fingerprint))
            
        if db_links is not None:
            
            _query_params.append(('dbLinks', db_links))
            
        if pub_med_ids is not None:
            
            _query_params.append(('pubMedIds', pub_med_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/projects/{projectId}/compounds/{compoundId}/top-structure',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


